#!/usr/bin/env python3

import argparse
import json
import os
import sys
import subprocess as sp
from urllib.request import urlretrieve


# parse arguments from the cli. Only for testing/advanced use.
def process_args():
    parser = argparse.ArgumentParser()
    parser.add_argument("-v", "--verbose", action="store_true", dest="verbose", default=False,
                        help="Print more output")
    parser.add_argument("-b", "--board_name", dest="board_name", type=str, nargs=1, default=[""],
                        help="Override board name. FOR TESTING ONLY")
    parser.add_argument("--force-avs-install", action="store_true", dest="force_avs_install", default=False,
                        help="DANGEROUS: Force enable AVS install. MIGHT CAUSE PERMANENT DAMAGE TO SPEAKERS!")
    return parser.parse_args()


def avs_audio(board, username):
    print_status("Installing AVS")
    if args.force_avs_install:
        print_error("WARNING: AVS is unstable and can cause permanent damage to your speakers if your device has max98357a!")
        user_input = input('Type "I understand the risk of permanently damaging my speakers" in all caps to continue: ')
        while user_input != "I UNDERSTAND THE RISK OF PERMANENTLY DAMAGING MY SPEAKERS":
            user_input = input(
                'Type "I understand the risk of permanently damaging my speakers" in all caps to continue: ')
        override_avs = True
    else:
        print_error("WARNING: AVS is unstable and can cause permanent damage to your speakers if your device has max98357a! "
                    "As a safety precaution devices with max98357a have speakers disabled until a fix is in place. "
                    "Headphones and HDMI audio are safe from this. If the driver crashes reboot to fix it.")
        print_question("If you want to disable this check, restart the script with --force-avs-install")

        user_input = input('Type "I Understand my speakers will not work if my device has max98357a!" in all caps to continue: ')
        while user_input != "I UNDERSTAND MY SPEAKERS WILL NOT WORK IF MY DEVICE HAS MAX98357A!":
            user_input = input('Type "I Understand my speakers will not work if my device has max98357a!" in all caps to continue: ')
        override_avs = False

    # Clone ucm repo
    bash("git clone https://github.com/eupnea-linux/ucm-configs /tmp/ucm-configs")
    cpdir("/tmp/ucm-configs/avs/", "/usr/share/alsa/ucm2/conf.d/")

    # avs tplg is from https://github.com/thesofproject/avs-topology-xml
    cpdir(f"{config_path}/audio/avs/tplg", "/lib/firmware/intel/avs")
    cpfile(f"{config_path}/audio/avs/snd-avs.conf", "/etc/modprobe.d/snd-avs.conf")

    # avs dsp firmware recently got merged upstream but is not packaged in any distro yet
    mkdir("/lib/firmware/intel/avs/skl")
    mkdir("/lib/firmware/intel/avs/apl")
    urlretrieve("https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/intel/avs/apl/dsp_basefw.bin", filename="/lib/firmware/intel/avs/apl/dsp_basefw.bin")
    urlretrieve("https://git.kernel.org/pub/scm/linux/kernel/git/firmware/linux-firmware.git/plain/intel/avs/skl/dsp_basefw.bin", filename="/lib/firmware/intel/avs/skl/dsp_basefw.bin")

    # Install specific blobs for rammus and nocturne
    if board in ["rammus", "shyvana", "leona"]:
        extract_blobs("rammus")
        print_error("WARNING: You will need a chromeos kernel for speakers to work!")
    if board == "nocturne":
        extract_blobs("nocturne")
        print_error("WARNING: You will need a chromeos kernel for speakers to work!")

    # Delete topology for max98357a to prevent it from working until there is a volume limiter.
    if not override_avs:
        rmfile("/lib/firmware/intel/avs/max98357a-tplg.bin")

    if not path_exists(f"/lib/modules/{bash('uname -r')}/kernel/sound/soc/intel/avs"):
        print_error("Looks like your kernel doesn't have the avs modules. Make sure you are on atlest 6.0 with avs "
                    "enabled. If you are on a Eupnea Project kernel update your system.")

    # Service for automatically switching between speakers and headphones
    user_input = input("Would you like to install the automatic speaker and headphone switching service? (y/n)").lower()
    if user_input == "y":
        install_package("acpid", "acpid", "acpid", "acpid", "acpid")
        bash("systemctl enable acpid")
        bash("git clone https://github.com/WeirdTreeThing/avs-auto-switcher /tmp/avs-auto-switcher")
        cpfile("/tmp/avs-auto-switcher/avs-auto-switcher", "/usr/local/bin/avs-auto-switcher")
        cpfile("/tmp/avs-auto-switcher/avs-auto-switcher.service", "/usr/lib/systemd/user/avs-auto-switcher.service")
        bash(f"systemctl --machine={username}@.host --user --now enable avs-auto-switcher")


def apl_audio(board, username):
    print_status("Apollolake has two audio drivers:")
    print_status("SOF: Stable but doesn't work with headphones or mic.")
    print_status("AVS: Unstable and can cause damage to speakers but supports all audio hardware.")
    print_error("NOTE: Speakers are disabled on AVS as a safety precaution. "
                "Your speakers will still work on SOF though.")

    while True:
        user_input = input("Which driver would you like to use? [sof/avs]: ")
        if user_input.lower() == "sof":
            print_status("Using sof")
            # Remove avs modprobe config if it exists
            rmfile("/etc/modprobe.d/snd-avs.conf")
            sof_audio("apl")
            print_status("Important: After rebooting you will need to enable the audio output device!")
            break
        elif user_input.lower() == "avs":
            print_status("Using avs")
            # Remove sof modprobe config if it exists
            rmfile("/etc/modprobe.d/alsa-sof.conf")
            avs_audio(board, username)
            break
        else:
            print_error(f"Invalid option: {user_input}")
            continue


def sof_audio(platform):
    print_status("Installing SOF")

    # Don't allow running this on Tigerlake models with max98357a
    if "tgl" in platform:
        try:
            bash("dmesg | grep MX98357A")
            print_error("Your device uses max98357a which is known to cause permanent damage to speakers! "
                        "As a safety precaution the sound drivers have been blocked from loading.")
            cpfile(f"{config_path}/audio/sof/blacklist-sof.conf", "/etc/modprobe.d/blacklist-sof.conf")
            exit(0)
        except subprocess.CalledProcessError:
            rmfile("/etc/modprobe.d/blacklist-sof.conf")

    # Install required packages
    # Sof firmware needs to be reinstalled for some reason.
    install_package("sof-firmware", "firmware-sof-signed", "alsa-sof-firmware", "sof-firmware", "sof-firmware",
                    reinstall=True)
    # linux-firmware has different names on ubuntu and debian
    with open("/etc/os-release") as f:
        if "ubuntu" in f.read():
            install_package(deb_package="linux-firmware")
        else:
            install_package("linux-firmware", "firmware-linux-free firmware-linux-nonfree", "linux-firmware",
                            "kernel-firmware", "linux-firmware")
    install_package("alsa-utils", "alsa-utils", "alsa-utils", "alsa-utils", "alsa-utils")

    # Force sof driver
    cpfile(f"{config_path}/audio/sof/alsa-sof.conf", "/etc/modprobe.d/alsa-sof.conf")

    # Delete repo just in case it already exists
    rmdir("/tmp/ucm-configs")
    # Clone ucm repo
    bash("git clone https://github.com/eupnea-linux/ucm-configs /tmp/ucm-configs")
    match platform:
        case "glk":
            # Most glk devices use da7219/max98357a
            cpdir("/tmp/ucm-configs/glk/sof-glkda7219ma", "/usr/share/alsa/ucm2/conf.d/sof-glkda7219ma")
            # Some glk devices use cs42l42
            cpdir("/tmp/ucm-configs/glk/sof-cs42l42", "/usr/share/alsa/ucm2/conf.d/sof-cs42l42")
            # Same thing for rt5682
            cpdir("/tmp/ucm-configs/glk/sof-glkrt5682ma", "/usr/share/alsa/ucm2/conf.d/sof-glkrt5682ma")
        case "cml":
            cpdir("/tmp/ucm-configs/cml/sof-rt5682", "/usr/share/alsa/ucm2/conf.d/sof-rt5682")
            cpdir("/tmp/ucm-configs/cml/sof-cmlda7219ma", "/usr/share/alsa/ucm2/conf.d/sof-cmlda7219ma")
            cpdir("/tmp/ucm-configs/cml/sof-cml_rt1011_", "/usr/share/alsa/ucm2/conf.d/sof-cml_rt1011_")
        case "tgl":
            cpdir("/tmp/ucm-configs/tgl/sof-rt5682", "/usr/share/alsa/ucm2/conf.d/sof-rt5682")
        case "jsl":
            cpdir("/tmp/ucm-configs/jsl/sof-rt5682", "/usr/share/alsa/ucm2/conf.d/sof-rt5682")
            cpdir("/tmp/ucm-configs/jsl/sof-da7219max98", "/usr/share/alsa/ucm2/conf.d/sof-da7219max98")
            # JSL needs topology from ChromeOS
            extract_blobs("jsl")


def bsw_audio():
    print_status("Fixing braswell audio")
    cpfile(f"{config_path}/audio/sof/bsw-sof.conf", "/etc/modprobe.d/bsw-sof.conf")


def zen2_audio(username):
    print_status("Installing zen2 audio")
    update_system()
    if not bash("ps -e").__contains__("pipewire-pulse"):  # Check if pipewire is running
        print_status("PipeWire is not running, installing it")
        if Path("/usr/bin/pacman").exists():
            bash("yes | pacman -S wireplumber")  # force resolve dependencies
            bash("yes | pacman -S pipewire-pulse")  # force resolve dependencies
            # Enable + start pipewire
            bash(f"systemctl --machine={username}@.host --user --now enable pipewire.service pipewire-pulse.service "
                 f"wireplumber.service")

        elif path_exists("/usr/bin/apt"):
            with open("/etc/os-release", "r") as file:
                os_release = file.read().lower()
            # Remove pulseaudio and install pipewire on ubuntu 22.04 or 22.10
            # On 22.10 some DEs still use pulseaudio
            if "ubuntu 22.10" in os_release or "ubuntu 22.04" in os_release:
                # https://ubuntuhandbook.org/index.php/2022/04/pipewire-replace-pulseaudio-ubuntu-2204/
                install_package(deb_package="pipewire pipewire-pulse")
                bash("apt-get remove -y pulseaudio-module-bluetooth")  # Remove pulseaudio bluetooth module
                install_package(deb_package="pipewire-audio-client-libraries libspa-0.2-bluetooth libspa-0.2-jack "
                                            "wireplumber pipewire-media-session-")

                # copy config files
                cpfile("/usr/share/doc/pipewire/examples/alsa.conf.d/99-pipewire-default.conf",
                       "/etc/alsa/conf.d/99-pipewire-default.conf")
                cpfile("/usr/share/doc/pipewire/examples/ld.so.conf.d/pipewire-jack-x86_64-linux-gnu.conf",
                       "/etc/ld.so.conf.d/pipewire-jack-x86_64-linux-gnu.conf")
                bash("ldconfig")  # auto-create links

                # enable wireplumber
                bash(f"systemctl --machine={username}@.host --user --now enable wireplumber.service")

            elif "debian gnu/linux 11 (bullseye)" in os_release:
                # https://trendoceans.com/install-pipewire-on-debian-11/
                install_package(deb_package="pipewire pipewire-audio-client-libraries")
                open("/etc/pipewire/media-session.d/with-pulseaudio", 'a').close()  # create an empty file
                cpfile("/usr/share/doc/pipewire/examples/systemd/user/pipewire-pulse.service",
                       "/etc/systemd/user/pipewire-pulse.service")
                cpfile("/usr/share/doc/pipewire/examples/systemd/user/pipewire-pulse.socket",
                       "/etc/systemd/user/pipewire-pulse.socket")

                # Reload systemd configs
                bash(f"systemctl --machine={username}@.host --user daemon-reload")
                # fully disable pulseaudio
                bash(f"systemctl --machine={username}@.host --user --now disable pulseaudio.service pulseaudio.socket")
                bash(f"systemctl --machine={username}@.host --user mask pulseaudio")
                # enable pipewire
                bash(f"systemctl --machine={username}@.host --user --now enable pipewire pipewire-pulse")
        else:
            print_error(f"Something went wrong => open a github issue or create a post on the discord\nError: Distro "
                        f"not recognized (zen2 audio)")
            exit(1)
    else:
        print_status("PipeWire is already configured")

    # remove old files
    rmdir("/usr/share/alsa/ucm2/AMD/acp3xalc5682m98/")
    rmdir("/usr/share/alsa/ucm2/conf.d/acp3xalc5682m98")

    # clone repo
    bash("git clone --depth=1 https://github.com/alsa-project/alsa-ucm-conf/ /tmp/eupnea-audio")

    # Make directories
    mkdir("/usr/share/alsa/ucm2/AMD/acp3xalc5682m98/", create_parents=True)
    mkdir("/usr/share/alsa/ucm2/conf.d/acp3xalc5682m98", create_parents=True)

    # copy ucm configs
    cpfile("/tmp/eupnea-audio/ucm2/AMD/acp3xalc5682m98/HiFi.conf",
           "/usr/share/alsa/ucm2/AMD/acp3xalc5682m98/HiFi.conf")
    cpfile("/tmp/eupnea-audio/ucm2/AMD/acp3xalc5682m98/acp3xalc5682m98.conf",
           "/usr/share/alsa/ucm2/AMD/acp3xalc5682m98/acp3xalc5682m98.conf")
    bash("cd /usr/share/alsa/ucm2/conf.d/acp3xalc5682m98 ; ln ../../AMD/acp3xalc5682m98/acp3xalc5682m98.conf")

    # speaker warning
    print_status("After rebooting you will need to set speakers as the output device in sound settings.")


def install_package(arch_package: str = "", deb_package: str = "", rpm_package: str = "", suse_package: str = "",
                    void_package: str = "", reinstall: bool = False):
    with open("/etc/os-release", "r") as file:
        distro = file.read()
    if distro.lower().__contains__(
            "arch"):  # might accidentally catch architecture stuff, but needed to catch arch derivatives
        if reinstall:
            bash(f"pacman -S --noconfirm {arch_package}")
        else:
            bash(f"pacman -S --noconfirm --needed {arch_package}")
    elif distro.lower().__contains__("void"):
        if reinstall:
            bash(f"xbps-install -fy {void_package}")
        else:
            bash(f"xbps-install -y {void_package}")
    elif distro.lower().__contains__("ubuntu") or distro.lower().__contains__("debian"):
        if reinstall:
            bash(f"apt-get install -y --reinstall {deb_package}")
        else:
            bash(f"apt-get install -y {deb_package}")
    elif distro.lower().__contains__("suse"):
        if reinstall:
            bash(f"zypper --non-interactive -f install {suse_package}")
        else:
            bash(f"zypper --non-interactive install {suse_package}")
    elif distro.lower().__contains__("fedora"):
        if reinstall:
            bash(f"dnf reinstall -y {rpm_package}")
        else:
            bash(f"dnf install -y {rpm_package}")
    else:
        print_error(f"Unknown package manager! Please install {deb_package} using your package manager.")


def extract_blobs(platform) -> None:
    if platform in ["rammus", "nocturne"]: # rammus and nocturne need same blobs, just from different recovery image
        NOCTURNE_URL = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_15278.64.0_nocturne_recovery_stable-channel_mp.bin.zip"
        NOCTURNE_BIN = "chromeos_15278.64.0_nocturne_recovery_stable-channel_mp.bin"
        RAMMUS_URL = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_15278.64.0_rammus_recovery_stable-channel_mp-v2.bin.zip"
        RAMMUS_BIN = "chromeos_15278.64.0_rammus_recovery_stable-channel_mp-v2.bin"
        print_question("Your device needs special firmware files for speakers to work which need to be extracted from a ChromeOS recovery image. "
                       "You will need around 6GB of free space to download and extract it")
        user_input = input("Would you like to download and extract the firmware? [y/n] ")
        if user_input.lower == "y":
            print_status("Installing deps")
            install_package("unzip", "unzip", "unzip", "unzip", "unzip")
            install_package("multipath-tools", "multipath-tools", "multipath-tools", "multipath-tools", "multipath-tools")
            if "rammus" in platform:
                print_status("Downloading")
                urlretrieve(RAMMUS_URL, filename="/tmp/rammus.bin.zip") # Download to /var/tmp
                print_status("Extracting recovery image")
                bash("unzip /var/tmp/rammus.bin.zip -d /var/tmp")
                rmfile("/var/tmp/rammus.bin.zip")
                loop_dev = str(sp.check_output(f"kpartx -av /var/tmp/{RAMMUS_BIN}"))[8:14]
                # Handle 1 digit loop devs
                if loop_dev[5] == "p":
                    loop_dev = loop_dev[:5]
                mkdir("/mnt/cros")
                bash(f"mount /dev/{loop_dev}p3 /mnt/cros -o ro")
                print_status("Extracting firmware")
                # extract avs firmware
                cpdir("/mnt/cros/lib/firmware/intel/avs", "/lib/firmware/intel/avs")
                # extract dsm config
                mkdir("/usr/lib/rammus-dsm/", create_parents=True)
                cpfile("/mnt/cros/opt/google/dsm/shyvana/dsmparam.bin", "/usr/bin/rammus-dsm/dsmparam.bin`") # Shyvana and leona have the same dsmparam.bin file
                print_status("Cleaning up")
                bash("umount /mnt/cros")
                rmdir("/mnt/cros")
                bash(f"kpartx -d /dev/{loop_dev}")
                bash(f"losetup -d /dev/{loop_dev}")
                rmfile(f"/var/tmp/{RAMMUS_BIN}")
            else:
                print_status("Downloading")
                urlretrieve(NOCTURNE_URL, filename="/var/tmp/nocturne.bin.zip")
                print_status("Extracting recovery image")
                bash("unzip /var/tmp/nocturne.bin.zip -d /var/tmp")
                rmfile("/var/tmp/nocturne.bin.zip")
                loop_dev = str(sp.check_output(f"kpartx -av /var/tmp/{NOCTURNE_BIN}"))[8:14]
                # Handle 1 digit loop devs
                if loop_dev[5] == "p":
                    loop_dev = loop_dev[:5]
                mkdir("/mnt/cros")
                bash(f"mount /dev/{loop_dev}p3 /mnt/cros -o ro")
                print_status("Extracting firmware")
                # extract avs firmware
                cpdir("/mnt/cros/lib/firmware/intel/avs", "/lib/firmware/intel/avs")
                # extract dsm config
                mkdir("/usr/lib/nocturne-dsm/", create_parents=True)
                cpfile("/mnt/cros/opt/google/dsm/dsmparam.bin", "/usr/bin/nocturne-dsm/dsmparam.bin`")
                print_status("Cleaning up")
                bash("umount /mnt/cros")
                rmdir("/mnt/cros")
                bash(f"kpartx -d /dev/{loop_dev}")
                bash(f"losetup -d /dev/{loop_dev}")
                rmfile(f"/var/tmp/{NOCTURNE_BIN}")
        else:
            print_status("Not installing firmware, speakers will not work!")
    elif "jsl" in platform:
        print_question("Your device needs a working topology file for speakers to work which need to be extracted from a ChromeOS recovery image. "
                       "You will need around 6GB of free space to download and extract it")
        user_input = input("Would you like to download and extract the topology? [y/n] ")
        if user_input.lower == "y":
            print_status("Installing deps")
            install_package("unzip", "unzip", "unzip", "unzip", "unzip")
            install_package("multipath-tools", "multipath-tools", "multipath-tools", "multipath-tools", "multipath-tools")
            DEDEDE_URL = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_15278.64.0_dedede_recovery_stable-channel_mp-v27.bin.zip"
            DEDEDE_BIN = "https://dl.google.com/dl/edgedl/chromeos/recovery/chromeos_15278.64.0_dedede_recovery_stable-channel_mp-v27.bin"
            print_status("Downloading")
            urlretrieve(DEDEDE_URL, filename="/var/tmp/dedede.bin.zip")
            print_status("Extracting recovery image")
            bash("unzip /var/tmp/dedede.bin.zip -d /var/tmp")
            rmfile("/var/tmp/dedede.bin.zip")
            loop_dev = str(sp.check_output(f"kpartx -av /var/tmp{DEDEDE_BIN}"))[8:14]
            # Handle 1 digit loop devs
            if loop_dev[5] == "p":
                loop_dev = loop_dev[:5]
            mkdir("/mnt/cros")
            bash(f"mount /dev/{loop_dev}p3 /mnt/cros -o ro")
            print_status("Extracting firmware")
            # Remove old topology
            rmfile("/lib/firmware/intel/sof-tplg/sof-jsl-rt5682-rt1015.tplg")
            # Install new topology
            cpfile("/mnt/cros/lib/firmware/intel/sof-tplg/sof-jsl-rt5682-rt1015.tplg", "/lib/firmware/intel/sof-tplg/sof-jsl-rt5682-rt1015.tplg")
            print_status("Cleaning up")
            bash("umount /mnt/cros")
            rmdir("/mnt/cros")
            bash(f"kpartx -d /dev/{loop_dev}")
            bash(f"losetup -d /dev/{loop_dev}")
            rmfile(f"/var/tmp/{NOCTURNE_BIN}")


def update_system() -> None:
    with open("/etc/os-release", "r") as os:
        distro = os.read()
    if distro.lower().__contains__(
            "arch"):  # might accidentally catch architecture stuff, but needed to catch arch derivatives
        bash("pacman -Syu")
    elif distro.lower().__contains__("void"):
        bash("xbps-install -Syu")
    elif distro.lower().__contains__("ubuntu") or distro.lower().__contains__("debian"):
        bash("apt-get update")
        bash("apt-get -y upgrade")
    elif distro.lower().__contains__("suse"):
        bash("yes | zypper up")
    elif distro.lower().__contains__("fedora"):
        bash("dnf upgrade -y")
    else:
        print_warning("Unknown package manager! Cannot update system. Skipping")


if __name__ == "__main__":
    # Determine if running from a git clone or a eupnea system
    if sys.argv[0] == "/usr/bin/setup-audio":
        config_path = "/etc/eupnea"
        sys.path.insert(0, "/usr/lib/eupnea")
    else:
        config_path = "configs"
    from functions import *

    if os.geteuid() == 0 and not path_exists("/tmp/username"):
        print_error("Please start the script as non-root/without sudo")
        exit(1)

    args = process_args()  # process args before elevating to root for better ux

    # Test internet connection
    skip_check = False
    try:
        bash("which ping")
    except subprocess.CalledProcessError:
        print_error("Ping not found. Skipping internet connection check.")
        skip_check = True
    if skip_check:
        try:
            bash("ping -c 1 github.com")
        except subprocess.CalledProcessError:
            print_error("No internet connection! Please connect to the internet and try again.")
            exit(1)

    # Restart script as root
    if os.geteuid() != 0:
        # save username
        with open("/tmp/username", "w") as file:
            # get non-root username. os.getlogin() seems to fail in chroots
            file.write(bash("whoami").strip())

        # restart script as root
        sudo_args = ['sudo', sys.executable] + sys.argv + [os.environ]
        os.execlpe('sudo', *sudo_args)

    # read username
    with open("/tmp/username", "r") as file:
        user_id = file.read()

    if args.verbose:
        print_warning("Verbosity increased")
        set_verbose(args.verbose)

    # Remove old files
    rmdir("/tmp/eupnea-audio")
    mkdir("/tmp/eupnea-audio")

    # Important message
    print_warning("WARNING: this audio script is not fully functional yet!")

    if args.board_name[0] == "":
        # Get the board name from dmi
        with open("/sys/devices/virtual/dmi/id/product_name", "r") as dmi:
            device_board = dmi.read().lower().strip()
    else:  # use the board name from the args, for testing only
        device_board = str(args.board_name[0]).lower().strip()
        print_warning(f"Board name overriden to: {device_board}")

    with open(f"{config_path}/audio/board-generations.json", "r") as file:
        boards = json.load(file)

    try:
        match boards[device_board]:
            case "bsw":
                bsw_audio()
            case "skl":
                avs_audio(device_board, user_id)
            case "kbl":
                avs_audio(device_board, user_id)
            case "apl":
                apl_audio(device_board, user_id)
            case "glk":
                sof_audio("glk")
            case "cml":
                sof_audio("cml")
            case "jsl":
                sof_audio("jsl")
            case "tgl":
                sof_audio("tgl")
            case "str":
                print_error("StoneyRidge is not supported!")
                exit(0)
            case "zen2":
                zen2_audio(user_id)
            case _:
                print_error(f"Unknown/Unsupported chromebook model: {device_board}")
                exit(1)
    except KeyError:
        print_error(f"Unknown/Unsupported chromebook model: {device_board}")
        exit(1)

    print_header("Audio installed successfully! Reboot to finish setup.")
    input("\033[92m" + "Press ENTER to reboot or CTRL+C to cancel reboot" + "\033[0m")
    bash("reboot")
    sleep(5)
